[
["index.html", "An Introduction to Machine Learning with R Chapter 1 Preface 1.1 Caution 1.2 Installation 1.3 License 1.4 Contact", " An Introduction to Machine Learning with R Laurent Gatto 2019-06-17 Chapter 1 Preface This course material is aimed at people who are already familiar with the R language and syntax, and who would like to get a hands-on introduction to machine learning. 1.1 Caution This material is currently under development and is likely to change in the future. 1.2 Installation A set of packages that are used, either directly or indirectly are provided in the first chapter. A complete session information with all packages used to compile this document is available at the end. The source code for this document is available on GitHub at https://github.com/lgatto/IntroMachineLearningWithR/ A short URL for this book is http://bit.ly/intromlr 1.3 License This material is licensed under the Creative Commons Attribution-ShareAlike 3.0 License. Some content is inspired by other sources though, see the Credit section in the material. 1.4 Contact Feel free to contact me for any question or comments, preferably by opening an issue on GitHub. "],
["2-an-introduction-to-machine-learning-with-r.html", "Chapter 2 An Introduction to Machine Learning with R 2.1 Objectives and pre-requisites 2.2 Why R? 2.3 Overview of machine learning (ML) 2.4 Material and methods", " Chapter 2 An Introduction to Machine Learning with R This introductory workshop on machine learning with R is aimed at participants who are not experts in machine learning (introductory material will be presented as part of the course), but have some familiarity with scripting in general and R in particular. The workshop will offer a hands-on overview of typical machine learning applications in R, including unsupervised (clustering, such as hierarchical and k-means clustering, and dimensionality reduction, such as principal component analysis) and supervised methods (classification and regression, such as k-nearest neighbour and linear regression). We will also address questions such as model selection using cross-validation. The material has an important hands-on component and readers should have a computer running R 3.4.1 or later. 2.1 Objectives and pre-requisites The course aims at providing an accessible introduction to various machine learning methods and applications in R. The core of the courses focuses on unsupervised and supervised methods. The course contains numerous exercises to provide numerous opportunities to apply the newly acquired material. Participants are expected to be familiar with the R syntax and basic plotting functionality. At the end of the course, the participants are anticipated to be able to apply what they have learnt, as well as feel confident enough to explore and apply new methods. 2.2 Why R? R is one of the major languages for data science. It provides excellent visualisation features, which is essential to explore the data before submitting it to any automated learning, as well as assessing the results of the learning algorithm. Many R packages for machine learning are available off the shelf and many modern methods in statistical learning are implemented in R as part of their development. There are however other viable alternatives that benefit from similar advantages. If we consider Python for example, the scikit-learn library provides all the tools that we will discuss in this course. 2.3 Overview of machine learning (ML) In supervised learning (SML), the learning algorithm is presented with labelled example inputs, where the labels indicate the desired output. SML itself is composed of classification, where the output is categorical, and regression, where the output is numerical. In unsupervised learning (UML), no labels are provided, and the learning algorithm focuses solely on detecting structure in unlabelled input data. Note that there are also semi-supervised learning approaches that use labelled data to inform unsupervised learning on the unlabelled data to identify and annotate new classes in the dataset (also called novelty detection). Reinforcement learning, the learning algorithm performs a task using feedback from operating in a real or synthetic environment. 2.4 Material and methods 2.4.1 Example data Observations, examples or simply data points along the rows Features or variables along the columns Using the iris data as an example, for UML, we would have 4 features for each unlabelled example. Sepal.Length Sepal.Width Petal.Length Petal.Width 5.1 3.5 1.4 0.2 4.9 3.0 1.4 0.2 4.7 3.2 1.3 0.2 4.6 3.1 1.5 0.2 5.0 3.6 1.4 0.2 5.4 3.9 1.7 0.4 The same dataset used in the context of SML contains an additional column of labels, documenting the outcome or class of each example. Species Sepal.Length Sepal.Width Petal.Length Petal.Width setosa 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 The different datasets that are used throughout the course are collected and briefly described in the short Data chapter. 2.4.2 Packages library(BiocStyle) We will be using, directly or indirectly, the following packages through the chapters: caret ggplot2 mlbench class caTools randomForest impute ranger kernlab class glmnet naivebayes rpart rpart.plot See the full session information for more details. A more comprehensive list of machine learning libraries in R can be found at the CRAN Task View for Machine Learning and Statistical Learning. "],
["3-example-datasets.html", "Chapter 3 Example datasets 3.1 Edgar Anderson’s Iris Data 3.2 Motor Trend Car Road Tests 3.3 Sub-cellular localisation 3.4 The diamonds data 3.5 The Sonar data 3.6 Housing Values in Suburbs of Boston 3.7 Customer churn", " Chapter 3 Example datasets 3.1 Edgar Anderson’s Iris Data In R: library(BiocStyle) data(iris) From the iris manual page: This famous (Fisher’s or Anderson’s) iris data set gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica. library(DT) datatable(iris) For more details, see ?iris. 3.2 Motor Trend Car Road Tests In R data(mtcars) From the ?mtcars manual page: The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973-74 models). datatable(mtcars) For more details, see ?mtcars. 3.3 Sub-cellular localisation The hyperLOPIT2015 data is used to demonstrate t-SNE and its comparison to PCA. These data provide sub-cellular localisation of proteins in Mouse E14TG2a embryonic stem cells, as published in Christoforou et al. (2016). The data comes as an MSnSet object from the Biocpkg(&quot;MSnbase&quot;) package, specifically developed for such quantitative proteomics data. Alternatively, comma-separated files containing a somehow simplified version of the data can also be found here. These data are only used to illustrate some concepts and are not loaded and used directly to avoid installing numerous dependencies. They are available through the Bioconductor project and can be installed with # source(&quot;http://www.bioconductor.org/biocLite.R&quot;) BiocManager::install(c(&quot;MSnbsase&quot;, &quot;pRoloc&quot;)) ## software BiocManager::install(&quot;pRolocdata&quot;) ## date 3.4 The diamonds data The diamonds data ships with the ggplot2 package and predict the price (in US dollars) of about 54000 round cut diamonds. In R: library(&quot;ggplot2&quot;) ## Registered S3 methods overwritten by &#39;ggplot2&#39;: ## method from ## [.quosures rlang ## c.quosures rlang ## print.quosures rlang data(diamonds) datatable(diamonds) ## Warning in instance$preRenderHook(instance): It seems your data is too ## big for client-side DataTables. You may consider server-side processing: ## https://rstudio.github.io/DT/server.html See also ?diamonds. 3.5 The Sonar data The Sonar data from the mlbench package can be used to train a classifer to recognise mines from rocks using sonar data. The data is composed to 60 features representing the energy within a particular frequency band. In R: library(&quot;mlbench&quot;) data(Sonar) datatable(Sonar) See also ?Sonar. 3.6 Housing Values in Suburbs of Boston The Boston data from the MASS provides the median value of owner-occupied homes (medv) in $1000s as well as 13 other features for 506 homes in Boston. In R: library(&quot;MASS&quot;) data(Boston) datatable(Boston) See also ?Boston. 3.7 Customer churn This data from the C50 package and distributes a training set with 3333 samples and a test set containing 1667 samples of customer attrition. In R: library(&quot;C50&quot;) data(churn) dim(churnTrain) ## [1] 3333 20 dim(churnTest) ## [1] 1667 20 datatable(churnTrain) "],
["4-unsupervised-learning.html", "Chapter 4 Unsupervised Learning 4.1 Introduction 4.2 k-means clustering 4.3 Hierarchical clustering 4.4 Pre-processing 4.5 Principal component analysis (PCA) 4.6 t-Distributed Stochastic Neighbour Embedding", " Chapter 4 Unsupervised Learning 4.1 Introduction In unsupervised learning (UML), no labels are provided, and the learning algorithm focuses solely on detecting structure in unlabelled input data. One generally differentiates between Clustering, where the goal is to find homogeneous subgroups within the data; the grouping is based on distance between observations. Dimensionality reduction, where the goal is to identify patterns in the features of the data. Dimensionality reduction is often used to facilitate visualisation of the data, as well as a pre-processing method before supervised learning. UML presents specific challenges and benefits: there is no single goal in UML there is generally much more unlabelled data available than labelled data. 4.2 k-means clustering The k-means clustering algorithms aims at partitioning n observations into a fixed number of k clusters. The algorithm will find homogeneous clusters. In R, we use library(BiocStyle) stats::kmeans(x, centers = 3, nstart = 10) where x is a numeric data matrix centers is the pre-defined number of clusters the k-means algorithm has a random component and can be repeated nstart times to improve the returned model Challenge: To learn about k-means, let’s use the iris dataset with the sepal and petal length variables only (to facilitate visualisation). Create such a data matrix and name it x Run the k-means algorithm on the newly generated data x, save the results in a new variable cl, and explore its output when printed. The actual results of the algorithms, i.e. the cluster membership can be accessed in the clusters element of the clustering result output. Use it to colour the inferred clusters to generate a figure like that shown below. Figure 4.1: k-means algorithm on sepal and petal lengths i &lt;- grep(&quot;Length&quot;, names(iris)) x &lt;- iris[, i] cl &lt;- kmeans(x, 3, nstart = 10) plot(x, col = cl$cluster) 4.2.1 How does k-means work Initialisation: randomly assign class membership set.seed(12) init &lt;- sample(3, nrow(x), replace = TRUE) plot(x, col = init) Figure 4.2: k-means random intialisation Iteration: Calculate the centre of each subgroup as the average position of all observations is that subgroup. Each observation is then assigned to the group of its nearest centre. It’s also possible to stop the algorithm after a certain number of iterations, or once the centres move less than a certain distance. par(mfrow = c(1, 2)) plot(x, col = init) centres &lt;- sapply(1:3, function(i) colMeans(x[init == i, ], )) centres &lt;- t(centres) points(centres[, 1], centres[, 2], pch = 19, col = 1:3) tmp &lt;- dist(rbind(centres, x)) tmp &lt;- as.matrix(tmp)[, 1:3] ki &lt;- apply(tmp, 1, which.min) ki &lt;- ki[-(1:3)] plot(x, col = ki) points(centres[, 1], centres[, 2], pch = 19, col = 1:3) Figure 4.3: k-means iteration: calculate centers (left) and assign new cluster membership (right) Termination: Repeat iteration until no point changes its cluster membership. k-means convergence (credit Wikipedia) 4.2.2 Model selection Due to the random initialisation, one can obtain different clustering results. When k-means is run multiple times, the best outcome, i.e. the one that generates the smallest total within cluster sum of squares (SS), is selected. The total within SS is calculated as: For each cluster results: for each observation, determine the squared euclidean distance from observation to centre of cluster sum all distances Note that this is a local minimum; there is no guarantee to obtain a global minimum. Challenge: Repeat k-means on our x data multiple times, setting the number of iterations to 1 or greater and check whether you repeatedly obtain the same results. Try the same with random data of identical dimensions. cl1 &lt;- kmeans(x, centers = 3, nstart = 10) cl2 &lt;- kmeans(x, centers = 3, nstart = 10) table(cl1$cluster, cl2$cluster) ## ## 1 2 3 ## 1 0 41 0 ## 2 51 0 0 ## 3 0 0 58 cl1 &lt;- kmeans(x, centers = 3, nstart = 1) cl2 &lt;- kmeans(x, centers = 3, nstart = 1) table(cl1$cluster, cl2$cluster) ## ## 1 2 3 ## 1 41 0 0 ## 2 0 0 58 ## 3 0 51 0 set.seed(42) xr &lt;- matrix(rnorm(prod(dim(x))), ncol = ncol(x)) cl1 &lt;- kmeans(xr, centers = 3, nstart = 1) cl2 &lt;- kmeans(xr, centers = 3, nstart = 1) table(cl1$cluster, cl2$cluster) ## ## 1 2 3 ## 1 0 52 0 ## 2 0 0 46 ## 3 52 0 0 diffres &lt;- cl1$cluster != cl2$cluster par(mfrow = c(1, 2)) plot(xr, col = cl1$cluster, pch = ifelse(diffres, 19, 1)) plot(xr, col = cl2$cluster, pch = ifelse(diffres, 19, 1)) Figure 4.4: Different k-means results on the same (random) data 4.2.3 How to determine the number of clusters Run k-means with k=1, k=2, …, k=n Record total within SS for each value of k. Choose k at the elbow position, as illustrated below. Challenge Calculate the total within sum of squares for k from 1 to 5 for our x test data, and reproduce the figure above. ks &lt;- 1:5 tot_within_ss &lt;- sapply(ks, function(k) { cl &lt;- kmeans(x, k, nstart = 10) cl$tot.withinss }) plot(ks, tot_within_ss, type = &quot;b&quot;) 4.3 Hierarchical clustering 4.3.1 How does hierarchical clustering work Initialisation: Starts by assigning each of the n points its own cluster Iteration Find the two nearest clusters, and join them together, leading to n-1 clusters Continue the cluster merging process until all are grouped into a single cluster Termination: All observations are grouped within a single cluster. Figure 4.5: Hierarchical clustering: initialisation (left) and colour-coded results after iteration (right). The results of hierarchical clustering are typically visualised along a dendrogram, where the distance between the clusters is proportional to the branch lengths. Figure 4.6: Visualisation of the hierarchical clustering results on a dendrogram In R: Calculate the distance using dist, typically the Euclidean distance. Hierarchical clustering on this distance matrix using hclust Challenge Apply hierarchical clustering on the iris data and generate a dendrogram using the dedicated plot method. d &lt;- dist(iris[, 1:4]) hcl &lt;- hclust(d) hcl ## ## Call: ## hclust(d = d) ## ## Cluster method : complete ## Distance : euclidean ## Number of objects: 150 plot(hcl) 4.3.2 Defining clusters After producing the hierarchical clustering result, we need to cut the tree (dendrogram) at a specific height to defined the clusters. For example, on our test dataset above, we could decide to cut it at a distance around 1.5, with would produce 2 clusters. Figure 4.7: Cutting the dendrogram at height 1.5. In R we can us the cutree function to cut the tree at a specific height: cutree(hcl, h = 1.5) cut the tree to get a certain number of clusters: cutree(hcl, k = 2) Challenge Cut the iris hierarchical clustering result at a height to obtain 3 clusters by setting h. Cut the iris hierarchical clustering result at a height to obtain 3 clusters by setting directly k, and verify that both provide the same results. plot(hcl) abline(h = 3.9, col = &quot;red&quot;) cutree(hcl, k = 3) ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [36] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 3 2 3 2 3 2 3 3 3 3 2 3 2 3 3 2 3 ## [71] 2 3 2 2 2 2 2 2 2 3 3 3 3 2 3 2 2 2 3 3 3 2 3 3 3 3 3 2 3 3 2 2 2 2 2 ## [106] 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## [141] 2 2 2 2 2 2 2 2 2 2 cutree(hcl, h = 3.9) ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [36] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 3 2 3 2 3 2 3 3 3 3 2 3 2 3 3 2 3 ## [71] 2 3 2 2 2 2 2 2 2 3 3 3 3 2 3 2 2 2 3 3 3 2 3 3 3 3 3 2 3 3 2 2 2 2 2 ## [106] 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## [141] 2 2 2 2 2 2 2 2 2 2 identical(cutree(hcl, k = 3), cutree(hcl, h = 3.9)) ## [1] TRUE Challenge Using the same value k = 3, verify if k-means and hierarchical clustering produce the same results on the iris data. Which one, if any, is correct? km &lt;- kmeans(iris[, 1:4], centers = 3, nstart = 10) hcl &lt;- hclust(dist(iris[, 1:4])) table(km$cluster, cutree(hcl, k = 3)) ## ## 1 2 3 ## 1 0 34 28 ## 2 0 38 0 ## 3 50 0 0 par(mfrow = c(1, 2)) plot(iris$Petal.Length, iris$Sepal.Length, col = km$cluster, main = &quot;k-means&quot;) plot(iris$Petal.Length, iris$Sepal.Length, col = cutree(hcl, k = 3), main = &quot;Hierarchical clustering&quot;) ## Checking with the labels provided with the iris data table(iris$Species, km$cluster) ## ## 1 2 3 ## setosa 0 0 50 ## versicolor 48 2 0 ## virginica 14 36 0 table(iris$Species, cutree(hcl, k = 3)) ## ## 1 2 3 ## setosa 50 0 0 ## versicolor 0 23 27 ## virginica 0 49 1 4.4 Pre-processing Many of the machine learning methods that are regularly used are sensitive to difference scales. This applies to unsupervised methods as well as supervised methods, as we will see in the next chapter. A typical way to pre-process the data prior to learning is to scale the data, or apply principal component analysis (next section). Scaling assures that all data columns have a mean of 0 and standard deviation of 1. In R, scaling is done with the scale function. Challenge Using the mtcars data as an example, verify that the variables are of different scales, then scale the data. To observe the effect different scales, compare the hierarchical clusters obtained on the original and scaled data. colMeans(mtcars) ## mpg cyl disp hp drat wt ## 20.090625 6.187500 230.721875 146.687500 3.596563 3.217250 ## qsec vs am gear carb ## 17.848750 0.437500 0.406250 3.687500 2.812500 hcl1 &lt;- hclust(dist(mtcars)) hcl2 &lt;- hclust(dist(scale(mtcars))) par(mfrow = c(1, 2)) plot(hcl1, main = &quot;original data&quot;) plot(hcl2, main = &quot;scaled data&quot;) 4.5 Principal component analysis (PCA) Dimensionality reduction techniques are widely used and versatile techniques that can be used to: find structure in features pre-processing for other ML algorithms, and aid in visualisation. The basic principle of dimensionality reduction techniques is to transform the data into a new space that summarise properties of the whole data set along a reduced number of dimensions. These are then ideal candidates used to visualise the data along these reduced number of informative dimensions. 4.5.1 How does it work Principal Component Analysis (PCA) is a technique that transforms the original n-dimensional data into a new n-dimensional space. These new dimensions are linear combinations of the original data, i.e. they are composed of proportions of the original variables. Along these new dimensions, called principal components, the data expresses most of its variability along the first PC, then second, … Principal components are orthogonal to each other, i.e. non-correlated. Figure 4.8: Original data (left). PC1 will maximise the variability while minimising the residuals (centre). PC2 is orthogonal to PC1 (right). In R, we can use the prcomp function. Let’s explore PCA on the iris data. While it contains only 4 variables, is already becomes difficult to visualise the 3 groups along all these dimensions. pairs(iris[, -5], col = iris[, 5], pch = 19) Let’s use PCA to reduce the dimension. irispca &lt;- prcomp(iris[, -5]) summary(irispca) ## Importance of components: ## PC1 PC2 PC3 PC4 ## Standard deviation 2.0563 0.49262 0.2797 0.15439 ## Proportion of Variance 0.9246 0.05307 0.0171 0.00521 ## Cumulative Proportion 0.9246 0.97769 0.9948 1.00000 A summary of the prcomp output shows that along PC1 along, we are able to retain over 92% of the total variability in the data. Figure 4.9: Iris data along PC1. 4.5.2 Visualisation A biplot features all original points re-mapped (rotated) along the first two PCs as well as the original features as vectors along the same PCs. Feature vectors that are in the same direction in PC space are also correlated in the original data space. biplot(irispca) One important piece of information when using PCA is the proportion of variance explained along the PCs, in particular when dealing with high dimensional data, as PC1 and PC2 (that are generally used for visualisation), might only account for an insufficient proportion of variance to be relevant on their own. In the code chunk below, I extract the standard deviations from the PCA result to calculate the variances, then obtain the percentage of and cumulative variance along the PCs. var &lt;- irispca$sdev^2 (pve &lt;- var/sum(var)) ## [1] 0.924618723 0.053066483 0.017102610 0.005212184 cumsum(pve) ## [1] 0.9246187 0.9776852 0.9947878 1.0000000 Challenge Repeat the PCA analysis on the iris dataset above, reproducing the biplot and preparing a barplot of the percentage of variance explained by each PC. It is often useful to produce custom figures using the data coordinates in PCA space, which can be accessed as x in the prcomp object. Reproduce the PCA plots below, along PC1 and PC2 and PC3 and PC4 respectively. par(mfrow = c(1, 2)) plot(irispca$x[, 1:2], col = iris$Species) plot(irispca$x[, 3:4], col = iris$Species) 4.5.3 Data pre-processing library(BiocStyle) We haven’t looked at other prcomp parameters, other that the first one, x. There are two other ones that are or importance, in particular in the light of the section on pre-processing above, which are center and scale.. The former is set to TRUE by default, while the second one is set the FALSE. Challenge Repeat the analysis comparing the need for scaling on the mtcars dataset, but using PCA instead of hierarchical clustering. When comparing the two. par(mfrow = c(1, 2)) biplot(prcomp(mtcars, scale = FALSE), main = &quot;No scaling&quot;) ## 1 biplot(prcomp(mtcars, scale = TRUE), main = &quot;With scaling&quot;) ## 2 Without scaling, disp and hp are the features with the highest loadings along PC1 and 2 (all others are negligible), which are also those with the highest units of measurement. Scaling removes this effect. 4.5.4 Final comments on PCA Real datasets often come with missing values. In R, these should be encoded using NA. Unfortunately, PCA cannot deal with missing values, and observations containing NA values will be dropped automatically. This is a viable solution only when the proportion of missing values is low. It is also possible to impute missing values. This is described in greater details in the Data pre-processing section in the supervised machine learning chapter. Finally, we should be careful when using categorical data in any of the unsupervised methods described above. Categories are generally represented as factors, which are encoded as integer levels, and might give the impression that a distance between levels is a relevant measure (which it is not, unless the factors are ordered). In such situations, categorical data can be dropped, or it is possible to encode categories as binary dummy variables. For example, if we have 3 categories, say A, B and C, we would create two dummy variables to encode the categories as: x y A 1 0 B 0 1 C 0 0 so that the distance between each category are approximately equal to 1. 4.6 t-Distributed Stochastic Neighbour Embedding t-Distributed Stochastic Neighbour Embedding (t-SNE) is a non-linear dimensionality reduction technique, i.e. that different regions of the data space will be subjected to different transformations. t-SNE will compress small distances, thus bringing close neighbours together, and will ignore large distances. It is particularly well suited for very high dimensional data. In R, we can use the Rtsne function from the Rtsne. Before, we however need to remove any duplicated entries in the dataset. library(&quot;Rtsne&quot;) uiris &lt;- unique(iris[, 1:5]) iristsne &lt;- Rtsne(uiris[, 1:4]) plot(iristsne$Y, col = uiris$Species) As with PCA, the data can be scaled and centred prior the running t-SNE (see the pca_center and pca_scale arguments). The algorithm is stochastic, and will produce different results at each repetition. 4.6.1 Parameter tuning t-SNE (as well as many other methods, in particular classification algorithms) has two important parameters that can substantially influence the clustering of the data Perplexity: balances global and local aspects of the data. Iterations: number of iterations before the clustering is stopped. It is important to adapt these for different data. The figure below shows a 5032 by 20 dataset that represent protein sub-cellular localisation. Effect of different perplexity and iterations when running t-SNE As a comparison, below are the same data with PCA (left) and t-SNE (right). PCA and t-SNE on hyperLOPIT "],
["5-supervised-learning.html", "Chapter 5 Supervised Learning 5.1 Introduction 5.2 Preview 5.3 Model performance 5.4 Classification performance 5.5 Random forest 5.6 Data pre-processing 5.7 Scaling and centering 5.8 Model selection", " Chapter 5 Supervised Learning 5.1 Introduction library(BiocStyle) In supervised learning (SML), the learning algorithm is presented with labelled example inputs, where the labels indicate the desired output. SML itself is composed of classification, where the output is qualitative, and regression, where the output is quantitative. When two sets of labels, or classes, are available, one speaks of binary classification. A classical example thereof is labelling an email as spam or not spam. When more classes are to be learnt, one speaks of a multi-class problem, such as annotation of a new Iris example as being from the setosa, versicolor or virginica species. In these cases, the output is a single label (of one of the anticipated classes). If multiple labels may be assigned to each example, one speaks of multi-label classification. 5.2 Preview To start this chapter, let’s use a simple, but useful classification algorithm, k-nearest neighbours (kNN) to classify the iris flowers. We will use the knn function from the class package. K-nearest neighbours works by directly measuring the (Euclidean) distance between observations and inferring the class of unlabelled data from the class of its nearest neighbours. In the figure below, the unlabelled instances 1 and 2 will be assigned classes c1 (blue) and c2 (red) as their closest neighbours are red and blue, respectively. Figure 5.1: Schematic illustrating the k nearest neighbors algorithm. Typically in machine learning, there are two clear steps, where one first trains a model and then uses the model to predict new outputs (class labels in this case). In the kNN, these two steps are combined into a single function call to knn. Lets draw a set of 50 random iris observations to train the model and predict the species of another set of 50 randomly chosen flowers. The knn function takes the training data, the new data (to be inferred) and the labels of the training data, and returns (by default) the predicted class. set.seed(12L) tr &lt;- sample(150, 50) nw &lt;- sample(150, 50) library(&quot;class&quot;) knnres &lt;- knn(iris[tr, -5], iris[nw, -5], iris$Species[tr]) head(knnres) ## [1] versicolor setosa versicolor setosa setosa setosa ## Levels: setosa versicolor virginica We can now compare the observed kNN-predicted class and the expected known outcome and calculate the overall accuracy of our model. table(knnres, iris$Species[nw]) ## ## knnres setosa versicolor virginica ## setosa 20 0 0 ## versicolor 0 17 2 ## virginica 0 0 11 mean(knnres == iris$Species[nw]) ## [1] 0.96 We have omitted an important argument from knn, which is the parameter k of the classifier. This parameter defines how many nearest neighbours will be considered to assign a class to a new unlabelled observation. From the arguments of the function, args(knn) ## function (train, test, cl, k = 1, l = 0, prob = FALSE, use.all = TRUE) ## NULL we see that the default value is 1. But is this a good value? Wouldn’t we prefer to look at more neighbours and infer the new class using a vote based on more labels? Challenge Repeat the kNN classification above by using another value of k, and compare the accuracy of this new model to the one above. Make sure to use the same tr and nw training and new data to avoid any biases in the comparison. knnres5 &lt;- knn(iris[tr, -5], iris[nw, -5], iris$Species[tr], k = 5) mean(knnres5 == iris$Species[nw]) ## [1] 0.94 table(knnres5, knnres) ## knnres ## knnres5 setosa versicolor virginica ## setosa 20 0 0 ## versicolor 0 19 1 ## virginica 0 0 10 Challenge Rerun the kNN classifier with a value of k &gt; 1, and specify prob = TRUE to obtain the proportion of the votes for the winning class. knnres5prob &lt;- knn(iris[tr, -5], iris[nw, -5], iris$Species[tr], k = 5, prob = TRUE) table(attr(knnres5prob, &quot;prob&quot;)) ## ## 0.6 0.8 0.833333333333333 1 ## 3 13 1 33 This introductory example leads to two important and related questions that we need to consider: How can we do a good job in training and testing data? In the example above, we choose random training and new data. How can we estimate our model parameters (k in the example above) so as to obtain good classification accuracy? 5.3 Model performance 5.3.1 In-sample and out-of-sample error In supervised machine learning, we have a desired output and thus know precisely what is to be computed. It thus becomes possible to directly evaluate a model using a quantifiable and objective metric. For regression, we will use the root mean squared error (RMSE), which is what linear regression (lm in R) seeks to minimise. For classification, we will use model prediction accuracy. Typically, we won’t want to calculate any of these metrics using observations that were also used to calculate the model. This approach, called in-sample error leads to optimistic assessment of our model. Indeed, the model has already seen these data upon construction, and is considered optimised for these observations in particular; it is said to over-fit the data. We prefer to calculate an out-of-sample error, on new data, to gain a better idea of how to model performs on unseen data, and estimate how well the model generalises. In this course, we will focus on the caret package for Classification And REgression Training (see also https://topepo.github.io/caret/index.html). It provides a common and consistent interface to many, often repetitive, tasks in supervised learning. library(&quot;caret&quot;) ## Loading required package: lattice ## Loading required package: ggplot2 ## Registered S3 methods overwritten by &#39;ggplot2&#39;: ## method from ## [.quosures rlang ## c.quosures rlang ## print.quosures rlang The code chunk below uses the lm function to model the price of round cut diamonds and then predicts the price of these very same diamonds with the predict function. data(diamonds) model &lt;- lm(price ~ ., diamonds) p &lt;- predict(model, diamonds) Challenge Calculate the root mean squared error for the prediction above ## Error on prediction error &lt;- p - diamonds$price rmse_in &lt;- sqrt(mean(error^2)) ## in-sample RMSE rmse_in ## [1] 1129.843 Let’s now repeat the exercise above, but by calculating the out-of-sample RMSE. We prepare a 80/20 split of the data and use 80% to fit our model, and predict the target variable (this is called the training data), the price, on the 20% of unseen data (the testing data). Challenge Let’s create a random 80/20 split to define the test and train subsets. Train a regression model on the training data. Test the model on the testing data. Calculating the out-of-sample RMSE. set.seed(42) ntest &lt;- nrow(diamonds) * 0.80 test &lt;- sample(nrow(diamonds), ntest) model &lt;- lm(price ~ ., data = diamonds[test, ]) p &lt;- predict(model, diamonds[-test, ]) error &lt;- p - diamonds$price[-test] rmse_out &lt;- sqrt(mean(error^2)) ## out-of-sample RMSE rmse_out ## [1] 1137.466 The values for the out-of-sample RMSE will vary depending on what exact split was used. The diamonds is a rather extensive data set, and thus even when building our model using a subset of the available data (80% above), we manage to generate a model with a low RMSE, and possibly lower than the in-sample error. When dealing with datasets of smaller sizes, however, the presence of a single outlier in the train and test data split can substantially influence the model and the RMSE. We can’t rely on such an approach and need a more robust one where we can generate and use multiple, different train/test sets to sample a set of RMSEs, leading to a better estimate of the out-of-sample RMSE. 5.3.2 Cross-validation Instead of doing a single training/testing split, we can systematise this process, produce multiple, different out-of-sample train/test splits, that will lead to a better estimate of the out-of-sample RMSE. The figure below illustrates the cross validation procedure, creating 3 folds. One would typically do a 10-fold cross validation (if the size of the data permits it). We split the data into 3 random and complementary folds, so that each data point appears exactly once in each fold. This leads to a total test set size that is identical to the size of the full dataset but is composed of out-of-sample predictions. Schematic of 3-fold cross validation producing three training (blue) and testing (white) splits. After cross-validation, all models used within each fold are discarded, and a new model is built using the whole dataset, with the best model parameter(s), i.e those that generalised over all folds. This makes cross-validation quite time consuming, as it takes x+1 (where x in the number of cross-validation folds) times as long as fitting a single model, but is essential. Note that it is important to maintain the class proportions within the different folds, i.e. respect the proportion of the different classes in the original data. This is also taken care when using the caret package. The procedure of creating folds and training the models is handled by the train function in caret. Below, we apply it to the diamond price example that we used when introducing the model performance. We start by setting a random seed to be able to reproduce the example. We specify the method (the learning algorithm) we want to use. Here, we use &quot;lm&quot;, but, as we will see later, there are many others to choose from1. We then set the out-of-sample training procedure to 10-fold cross validation (method = &quot;cv&quot; and number = 10). To simplify the output in the material for better readability, we set the verbosity flag to FALSE, but it is useful to set it to TRUE in interactive mode. set.seed(42) model &lt;- train(price ~ ., diamonds, method = &quot;lm&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10, verboseIter = FALSE)) model ## Linear Regression ## ## 53940 samples ## 9 predictor ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 48547, 48545, 48546, 48545, 48546, 48546, ... ## Resampling results: ## ## RMSE Rsquared MAE ## 1130.819 0.9197489 740.5712 ## ## Tuning parameter &#39;intercept&#39; was held constant at a value of TRUE Once we have trained our model, we can directly use this train object as input to the predict method: p &lt;- predict(model, diamonds) error &lt;- p - diamonds$price rmse_xval &lt;- sqrt(mean(error^2)) ## xval RMSE rmse_xval ## [1] 1129.843 Challenge Train a linear model using 10-fold cross-validation and then use it to predict the median value of owner-occupied homes in Boston from the Boston dataset as described above. Then calculate the RMSE. library(&quot;MASS&quot;) data(Boston) model &lt;- train(medv ~ ., Boston, method = &quot;lm&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10)) model ## Linear Regression ## ## 506 samples ## 13 predictor ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 455, 456, 457, 456, 454, 456, ... ## Resampling results: ## ## RMSE Rsquared MAE ## 4.838479 0.7301286 3.433261 ## ## Tuning parameter &#39;intercept&#39; was held constant at a value of TRUE p &lt;- predict(model, Boston) sqrt(mean(p - Boston$medv)^2) ## [1] 6.647482e-14 5.4 Classification performance Above, we have used the RMSE to assess the performance of our regression model. When using a classification algorithm, we want to assess its accuracy to do so. 5.4.1 Confusion matrix Instead of calculating an error between predicted value and known value, in classification we will directly compare the predicted class matches with the known label. To do so, rather than calculating the mean accuracy as we did above, in the introductory kNN example, we can calculate a confusion matrix. A confusion matrix contrasts predictions to actual results. Correct results are true positives (TP) and true negatives (TN) are found along the diagonal. All other cells indicate false results, i.e false negatives (FN) and false positives (FP). Reference Yes Reference No Predicted Yes TP FP Predicted No FN TN The values that populate this table will depend on the cutoff that we set to define whether the classifier should predict Yes or No. Intuitively, we might want to use 0.5 as a threshold, and assign every result with a probability &gt; 0.5 to Yes and No otherwise. Let’s experiment with this using the Sonar dataset, and see if we can differentiate mines from rocks using a logistic classification model use the glm function from the stats package. library(&quot;mlbench&quot;) data(Sonar) ## 60/40 split tr &lt;- sample(nrow(Sonar), round(nrow(Sonar) * 0.6)) train &lt;- Sonar[tr, ] test &lt;- Sonar[-tr, ] model &lt;- glm(Class ~ ., data = train, family = &quot;binomial&quot;) p &lt;- predict(model, test, type = &quot;response&quot;) summary(p) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 0.8545 0.5123 1.0000 1.0000 cl &lt;- ifelse(p &gt; 0.5, &quot;M&quot;, &quot;R&quot;) table(cl, test$Class) ## ## cl M R ## M 12 31 ## R 31 9 The caret package offers its own, more informative function to calculate a confusion matrix: confusionMatrix(factor(cl), test$Class) ## Confusion Matrix and Statistics ## ## Reference ## Prediction M R ## M 12 31 ## R 31 9 ## ## Accuracy : 0.253 ## 95% CI : (0.1639, 0.3604) ## No Information Rate : 0.5181 ## P-Value [Acc &gt; NIR] : 1 ## ## Kappa : -0.4959 ## ## Mcnemar&#39;s Test P-Value : 1 ## ## Sensitivity : 0.2791 ## Specificity : 0.2250 ## Pos Pred Value : 0.2791 ## Neg Pred Value : 0.2250 ## Prevalence : 0.5181 ## Detection Rate : 0.1446 ## Detection Prevalence : 0.5181 ## Balanced Accuracy : 0.2520 ## ## &#39;Positive&#39; Class : M ## We get, among others the accuracy: \\(\\frac{TP + TN}{TP + TN + FP + FN}\\) the sensitivity (recall, TP rate): \\(\\frac{TP}{TP + FN}\\) the specificity: \\(\\frac{TN}{TN + FP}\\) positive predictive value (precision): \\(\\frac{TP}{TP + FP}\\) negative predictive value: \\(\\frac{TN}{TN + FN}\\) FP rate (fall-out): \\(\\frac{FP}{FP + TN}\\) Challenge Compare the model accuracy (or any other metric) using thresholds of 0.1 and 0.9. confusionMatrix(factor(ifelse(p &gt; 0.9, &quot;M&quot;, &quot;R&quot;)), test$Class) ## Confusion Matrix and Statistics ## ## Reference ## Prediction M R ## M 11 30 ## R 32 10 ## ## Accuracy : 0.253 ## 95% CI : (0.1639, 0.3604) ## No Information Rate : 0.5181 ## P-Value [Acc &gt; NIR] : 1.0000 ## ## Kappa : -0.4933 ## ## Mcnemar&#39;s Test P-Value : 0.8989 ## ## Sensitivity : 0.2558 ## Specificity : 0.2500 ## Pos Pred Value : 0.2683 ## Neg Pred Value : 0.2381 ## Prevalence : 0.5181 ## Detection Rate : 0.1325 ## Detection Prevalence : 0.4940 ## Balanced Accuracy : 0.2529 ## ## &#39;Positive&#39; Class : M ## confusionMatrix(factor(ifelse(p &gt; 0.1, &quot;M&quot;, &quot;R&quot;)), test$Class) ## Confusion Matrix and Statistics ## ## Reference ## Prediction M R ## M 12 31 ## R 31 9 ## ## Accuracy : 0.253 ## 95% CI : (0.1639, 0.3604) ## No Information Rate : 0.5181 ## P-Value [Acc &gt; NIR] : 1 ## ## Kappa : -0.4959 ## ## Mcnemar&#39;s Test P-Value : 1 ## ## Sensitivity : 0.2791 ## Specificity : 0.2250 ## Pos Pred Value : 0.2791 ## Neg Pred Value : 0.2250 ## Prevalence : 0.5181 ## Detection Rate : 0.1446 ## Detection Prevalence : 0.5181 ## Balanced Accuracy : 0.2520 ## ## &#39;Positive&#39; Class : M ## 5.4.2 Receiver operating characteristic (ROC) curve There is no reason to use 0.5 as a threshold. One could use a low threshold to catch more mines with less certainty or or higher threshold to catch fewer mines with more certainty. This illustrates the need to adequately balance TP and FP rates. We need to have a way to do a cost-benefit analysis, and the solution will often depend on the question/problem. One solution would be to try with different classification thresholds. Instead of inspecting numerous confusion matrices, it is possible to automate the calculation of the TP and FP rates at each threshold and visualise all results along a ROC curve. This can be done with the colAUC function from the caTools package: caTools::colAUC(p, test[[&quot;Class&quot;]], plotROC = TRUE) ## [,1] ## M vs. R 0.7767442 x: FP rate (1 - specificity) y: TP rate (sensitivity) each point along the curve represents a confusion matrix for a given threshold In addition, the colAUC function returns the area under the curve (AUC) model accuracy metric. This is single number metric, summarising the model performance along all possible thresholds: an AUC of 0.5 corresponds to a random model values &gt; 0.5 do better than a random guess a value of 1 represents a perfect model a value 0 represents a model that is always wrong 5.4.3 AUC in caret When using caret’s trainControl function to train a model, we can set it so that it computes the ROC and AUC properties for us. ## Create trainControl object: myControl myControl &lt;- trainControl( method = &quot;cv&quot;, ## cross validation number = 10, ## 10-fold summaryFunction = twoClassSummary, ## NEW classProbs = TRUE, # IMPORTANT verboseIter = FALSE ) ## Train glm with custom trainControl: model model &lt;- train(Class ~ ., Sonar, method = &quot;glm&quot;, ## to use glm&#39;s logistic regression trControl = myControl) ## Print model to console print(model) ## Generalized Linear Model ## ## 208 samples ## 60 predictor ## 2 classes: &#39;M&#39;, &#39;R&#39; ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 187, 188, 188, 187, 188, 187, ... ## Resampling results: ## ## ROC Sens Spec ## 0.733447 0.7477273 0.6688889 Challenge Define a train object that uses the AUC and 10-fold cross validation to classify the Sonar data using a logistic regression, as demonstrated above. 5.5 Random forest Random forest models are accurate and non-linear models and robust to over-fitting and hence quite popular. They however require hyperparameters to be tuned manually, like the value k in the example above. Building a random forest starts by generating a high number of individual decision trees. A single decision tree isn’t very accurate, but many different trees built using different inputs (with bootstrapped inputs, features and observations) enable us to explore a broad search space and, once combined, produce accurate models, a technique called bootstrap aggregation or bagging. 5.5.1 Decision trees A great advantage of decision trees is that they make a complex decision simpler by breaking it down into smaller, simpler decisions using a divide-and-conquer strategy. They basically identify a set of if-else conditions that split the data according to the value of the features. library(&quot;rpart&quot;) ## recursive partitioning m &lt;- rpart(Class ~ ., data = Sonar, method = &quot;class&quot;) library(&quot;rpart.plot&quot;) rpart.plot(m) Figure 5.2: Descision tree with its if-else conditions p &lt;- predict(m, Sonar, type = &quot;class&quot;) table(p, Sonar$Class) ## ## p M R ## M 95 10 ## R 16 87 Decision trees choose splits based on most homogeneous partitions, and lead to smaller and more homogeneous partitions over their iterations. An issue with single decision trees is that they can grow, and become large and complex with many branches, which corresponds to over-fitting. Over-fitting models noise, rather than general patterns in the data, focusing on subtle patterns (outliers) that won’t generalise. To avoid over-fitting, individual decision trees are pruned. Pruning can happen as a pre-condition when growing the tree, or afterwards, by pruning a large tree. Pre-pruning: stop growing process, i.e stops divide-and-conquer after a certain number of iterations (grows tree to a certain predefined level), or requires a minimum number of observations in each mode to allow splitting. Post-pruning: grow a large and complex tree, and reduce its size; nodes and branches that have a negligible effect on the classification accuracy are removed. 5.5.2 Training a random forest Let’s return to random forests and train a model using the train function from caret: set.seed(12) model &lt;- train(Class ~ ., data = Sonar, method = &quot;ranger&quot;) print(model) ## Random Forest ## ## 208 samples ## 60 predictor ## 2 classes: &#39;M&#39;, &#39;R&#39; ## ## No pre-processing ## Resampling: Bootstrapped (25 reps) ## Summary of sample sizes: 208, 208, 208, 208, 208, 208, ... ## Resampling results across tuning parameters: ## ## mtry splitrule Accuracy Kappa ## 2 gini 0.8090731 0.6131571 ## 2 extratrees 0.8136902 0.6234492 ## 31 gini 0.7736954 0.5423516 ## 31 extratrees 0.8285153 0.6521921 ## 60 gini 0.7597299 0.5140905 ## 60 extratrees 0.8157646 0.6255929 ## ## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1 ## Accuracy was used to select the optimal model using the largest value. ## The final values used for the model were mtry = 31, splitrule = ## extratrees and min.node.size = 1. plot(model) The main hyperparameter is mtry, i.e. the number of randomly selected variables used at each split. Two variables produce random models, while hundreds of variables tend to be less random, but risk over-fitting. The caret package can automate the tuning of the hyperparameter using a grid search, which can be parametrised by setting tuneLength (that sets the number of hyperparameter values to test) or directly defining the tuneGrid (the hyperparameter values), which requires knowledge of the model. model &lt;- train(Class ~ ., data = Sonar, method = &quot;ranger&quot;, tuneLength = 5) set.seed(42) myGrid &lt;- expand.grid(mtry = c(5, 10, 20, 40, 60), splitrule = c(&quot;gini&quot;, &quot;extratrees&quot;), min.node.size = 1) ## Minimal node size; default 1 for classification model &lt;- train(Class ~ ., data = Sonar, method = &quot;ranger&quot;, tuneGrid = myGrid, trControl = trainControl(method = &quot;cv&quot;, number = 5, verboseIter = FALSE)) print(model) ## Random Forest ## ## 208 samples ## 60 predictor ## 2 classes: &#39;M&#39;, &#39;R&#39; ## ## No pre-processing ## Resampling: Cross-Validated (5 fold) ## Summary of sample sizes: 166, 167, 167, 167, 165 ## Resampling results across tuning parameters: ## ## mtry splitrule Accuracy Kappa ## 5 gini 0.8076277 0.6098253 ## 5 extratrees 0.8416579 0.6784745 ## 10 gini 0.7927667 0.5799348 ## 10 extratrees 0.8418848 0.6791453 ## 20 gini 0.7882316 0.5718852 ## 20 extratrees 0.8516355 0.6991879 ## 40 gini 0.7880048 0.5716461 ## 40 extratrees 0.8371229 0.6695638 ## 60 gini 0.7833482 0.5613525 ## 60 extratrees 0.8322448 0.6599318 ## ## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1 ## Accuracy was used to select the optimal model using the largest value. ## The final values used for the model were mtry = 20, splitrule = ## extratrees and min.node.size = 1. plot(model) Challenge Experiment with training a random forest model as described above, by using 5-fold cross validation, and setting a tuneLength of 5. set.seed(42) model &lt;- train(Class ~ ., data = Sonar, method = &quot;ranger&quot;, tuneLength = 5, trControl = trainControl(method = &quot;cv&quot;, number = 5, verboseIter = FALSE)) plot(model) 5.6 Data pre-processing 5.6.1 Missing values Real datasets often come with missing values. In R, these should be encoded using NA. There are basically two approaches to deal with such cases. Drop the observations with missing values, or, if one feature contains a very high proportion of NAs, drop the feature altogether. These approaches are only applicable when the proportion of missing values is relatively small. Otherwise, it could lead to losing too much data. Impute (replace) missing values. Data imputation can however have critical consequences depending on the proportion of missing values and their nature. From a statistical point of view, missing values are classified as missing completely at random (MCAR), missing at random (MAR) or missing not at random (MNAR), and the type of the missing values will influence the efficiency of the imputation method. The figure below shows how different imputation methods perform depending on the proportion and nature of missing values (from Lazar et al., on quantitative proteomics data). Normalised RMSE (RMSE-observation standard deviation ration) describing the effect of different imputation methods depending on the nature and proportion of the missing values: kNN (a), SVDimpute (b), MLE (c), MinDet (d), and MinProb (e). Let’s start by simulating a dataset containing missing values using the mtcars dataset. Below, we will want to predict the mpg variable using cyl, disp, and hp, with the latter containing 10 missing values. data(mtcars) mtcars[sample(nrow(mtcars), 10), &quot;hp&quot;] &lt;- NA Y &lt;- mtcars$mpg ## target variable X &lt;- mtcars[, 2:4] ## predictors If we now wanted to train a model (using the non-formula interface): try(train(X, Y)) ## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 . ## ## Something is wrong; all the RMSE metric values are missing: ## RMSE Rsquared MAE ## Min. : NA Min. : NA Min. : NA ## 1st Qu.: NA 1st Qu.: NA 1st Qu.: NA ## Median : NA Median : NA Median : NA ## Mean :NaN Mean :NaN Mean :NaN ## 3rd Qu.: NA 3rd Qu.: NA 3rd Qu.: NA ## Max. : NA Max. : NA Max. : NA ## NA&#39;s :2 NA&#39;s :2 NA&#39;s :2 ## Error : Stopping (Note that the occurrence of the error will depend on the model chosen.) We could perform imputation manually, but caret provides a whole range of pre-processing methods, including imputation methods, that can directly be passed when training the model. 5.6.2 Median imputation Imputation using median of features. This method works well if the data are missing at random. train(X, Y, preProcess = &quot;medianImpute&quot;) ## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 . ## Random Forest ## ## 32 samples ## 3 predictor ## ## Pre-processing: median imputation (3) ## Resampling: Bootstrapped (25 reps) ## Summary of sample sizes: 32, 32, 32, 32, 32, 32, ... ## Resampling results across tuning parameters: ## ## mtry RMSE Rsquared MAE ## 2 2.345716 0.8457441 1.923509 ## 3 2.433508 0.8337201 2.007780 ## ## RMSE was used to select the optimal model using the smallest value. ## The final value used for the model was mtry = 2. Imputing using caret also allows us to optimise the imputation based on the cross validation splits, as train will do median imputation inside each fold. 5.6.3 kNN imputation If there is a systematic bias in the missing values, then median imputation is known to produce incorrect results. kNN imputation will impute missing values using other, similar non-missing rows. The default value is 5. train(X, Y, preProcess = &quot;knnImpute&quot;) ## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 . ## Random Forest ## ## 32 samples ## 3 predictor ## ## Pre-processing: nearest neighbor imputation (3), centered (3), scaled (3) ## Resampling: Bootstrapped (25 reps) ## Summary of sample sizes: 32, 32, 32, 32, 32, 32, ... ## Resampling results across tuning parameters: ## ## mtry RMSE Rsquared MAE ## 2 2.603630 0.8300018 2.145504 ## 3 2.635956 0.8228652 2.171091 ## ## RMSE was used to select the optimal model using the smallest value. ## The final value used for the model was mtry = 2. 5.7 Scaling and centering We have seen in the Unsupervised learning chapter how data at different scales can substantially disrupt a learning algorithm. Scaling (division by the standard deviation) and centering (subtraction of the mean) can also be applied directly during model training by setting. Note that they are set to be applied by default prior to training. train(X, Y, preProcess = &quot;scale&quot;) train(X, Y, preProcess = &quot;center&quot;) As we have discussed in the section on Principal Component Analysis, PCA can be used as pre-processing method, generating a set of high-variance and perpendicular predictors, preventing collinearity. train(X, Y, preProcess = &quot;pca&quot;) 5.7.1 Multiple pre-processing methods It is possible to chain multiple processing methods: imputation, center, scale, pca. train(X, Y, preProcess = c(&quot;knnImpute&quot;, &quot;center&quot;, &quot;scale&quot;, &quot;pca&quot;)) ## note: only 2 unique complexity parameters in default grid. Truncating the grid to 2 . ## Random Forest ## ## 32 samples ## 3 predictor ## ## Pre-processing: nearest neighbor imputation (3), centered (3), scaled ## (3), principal component signal extraction (3) ## Resampling: Bootstrapped (25 reps) ## Summary of sample sizes: 32, 32, 32, 32, 32, 32, ... ## Resampling results across tuning parameters: ## ## mtry RMSE Rsquared MAE ## 2 2.549263 0.8245732 2.125463 ## 3 2.553001 0.8256242 2.131125 ## ## RMSE was used to select the optimal model using the smallest value. ## The final value used for the model was mtry = 2. The pre-processing methods above represent a classical order of operations, starting with data imputation to remove missing values, then centering and scaling, prior to PCA. For further details, see ?preProcess. 5.8 Model selection In this final section, we are going to compare different predictive models and choose the best one using the tools presented in the previous sections. To to so, we are going to first create a set of common training controller object with the same train/test folds and model evaluation metrics that we will re-use. This is important to guarantee fair comparison between the different models. For this section, we are going to use the churn data. Below, we see that about 15% of the customers churn. It is important to maintain this proportion in all of the folds. library(&quot;C50&quot;) data(churn) table(churnTrain$churn)/nrow(churnTrain) ## ## yes no ## 0.1449145 0.8550855 Previously, when creating a train control object, we specified the method as &quot;cv&quot; and the number of folds. Now, as we want the same folds to be re-used over multiple model training rounds, we are going to pass the train/test splits directly. These splits are created with the createFolds function, which creates a list (here of length 5) containing the element indices for each fold. myFolds &lt;- createFolds(churnTrain$churn, k = 5) str(myFolds) ## List of 5 ## $ Fold1: int [1:667] 3 7 13 17 20 36 39 48 52 62 ... ## $ Fold2: int [1:667] 4 10 12 24 25 29 41 42 47 50 ... ## $ Fold3: int [1:667] 6 15 19 21 22 26 28 32 33 34 ... ## $ Fold4: int [1:666] 5 9 16 30 31 37 44 45 46 53 ... ## $ Fold5: int [1:666] 1 2 8 11 14 18 23 27 35 43 ... Challenge Verify that the folds maintain the proportion of yes/no results. sapply(myFolds, function(i) { table(churnTrain$churn[i])/length(i) }) ## Fold1 Fold2 Fold3 Fold4 Fold5 ## yes 0.1454273 0.1454273 0.1454273 0.1441441 0.1441441 ## no 0.8545727 0.8545727 0.8545727 0.8558559 0.8558559 We can now a train control object to be reused consistently for different model trainings. myControl &lt;- trainControl( summaryFunction = twoClassSummary, classProb = TRUE, verboseIter = FALSE, savePredictions = TRUE, index = myFolds ) 5.8.1 glmnet model The glmnet is a linear model with built-in variable selection and coefficient regularisation. glm_model &lt;- train(churn ~ ., churnTrain, metric = &quot;ROC&quot;, method = &quot;glmnet&quot;, tuneGrid = expand.grid( alpha = 0:1, lambda = 0:10/10), trControl = myControl) print(glm_model) ## glmnet ## ## 3333 samples ## 19 predictor ## 2 classes: &#39;yes&#39;, &#39;no&#39; ## ## No pre-processing ## Resampling: Bootstrapped (5 reps) ## Summary of sample sizes: 667, 667, 667, 666, 666 ## Resampling results across tuning parameters: ## ## alpha lambda ROC Sens Spec ## 0 0.0 0.7575175 0.249475840 0.9567544 ## 0 0.1 0.7769689 0.070920191 0.9921053 ## 0 0.2 0.7785410 0.016561567 0.9986842 ## 0 0.3 0.7784171 0.004659196 0.9994737 ## 0 0.4 0.7780007 0.000000000 1.0000000 ## 0 0.5 0.7775646 0.000000000 1.0000000 ## 0 0.6 0.7771289 0.000000000 1.0000000 ## 0 0.7 0.7767893 0.000000000 1.0000000 ## 0 0.8 0.7764375 0.000000000 1.0000000 ## 0 0.9 0.7761664 0.000000000 1.0000000 ## 0 1.0 0.7759360 0.000000000 1.0000000 ## 1 0.0 0.7200047 0.291397893 0.9434211 ## 1 0.1 0.5216114 0.000000000 1.0000000 ## 1 0.2 0.5000000 0.000000000 1.0000000 ## 1 0.3 0.5000000 0.000000000 1.0000000 ## 1 0.4 0.5000000 0.000000000 1.0000000 ## 1 0.5 0.5000000 0.000000000 1.0000000 ## 1 0.6 0.5000000 0.000000000 1.0000000 ## 1 0.7 0.5000000 0.000000000 1.0000000 ## 1 0.8 0.5000000 0.000000000 1.0000000 ## 1 0.9 0.5000000 0.000000000 1.0000000 ## 1 1.0 0.5000000 0.000000000 1.0000000 ## ## ROC was used to select the optimal model using the largest value. ## The final values used for the model were alpha = 0 and lambda = 0.2. plot(glm_model) Below, we are going to repeat this same modelling with a variety of different classifiers, some of which we haven’t looked at. This illustrates another advantage of of using meta-packages such as caret, that provide a consistant interface to different backends (in this case for machine learning). Once we have mastered the interface, it becomes easy to apply it to a new backend. Note that some of the model training below will take some time to run, depending on the tuning parameter settings. 5.8.2 random forest model Challenge Apply a random forest model, making sure you reuse the same train control object. rf_model &lt;- train(churn ~ ., churnTrain, metric = &quot;ROC&quot;, method = &quot;ranger&quot;, tuneGrid = expand.grid( mtry = c(2, 5, 10, 19), splitrule = c(&quot;gini&quot;, &quot;extratrees&quot;), min.node.size = 1), trControl = myControl) print(rf_model) ## Random Forest ## ## 3333 samples ## 19 predictor ## 2 classes: &#39;yes&#39;, &#39;no&#39; ## ## No pre-processing ## Resampling: Bootstrapped (5 reps) ## Summary of sample sizes: 667, 666, 667, 667, 666 ## Resampling results across tuning parameters: ## ## mtry splitrule ROC Sens Spec ## 2 gini 0.8691497 0.03419421 0.9999123 ## 2 extratrees 0.8313459 0.00000000 1.0000000 ## 5 gini 0.8873821 0.22153405 0.9964912 ## 5 extratrees 0.8709519 0.05126454 0.9999123 ## 10 gini 0.8963874 0.40527239 0.9910526 ## 10 extratrees 0.8872401 0.21374463 0.9980702 ## 19 gini 0.8999424 0.59368866 0.9833333 ## 19 extratrees 0.8942471 0.36641898 0.9918421 ## ## Tuning parameter &#39;min.node.size&#39; was held constant at a value of 1 ## ROC was used to select the optimal model using the largest value. ## The final values used for the model were mtry = 19, splitrule = gini ## and min.node.size = 1. plot(rf_model) 5.8.3 kNN model Challenge Apply a kNN model, making sure you reuse the same train control object. knn_model &lt;- train(churn ~ ., churnTrain, metric = &quot;ROC&quot;, method = &quot;knn&quot;, tuneLength = 20, trControl = myControl) print(knn_model) ## k-Nearest Neighbors ## ## 3333 samples ## 19 predictor ## 2 classes: &#39;yes&#39;, &#39;no&#39; ## ## No pre-processing ## Resampling: Bootstrapped (5 reps) ## Summary of sample sizes: 667, 666, 667, 667, 666 ## Resampling results across tuning parameters: ## ## k ROC Sens Spec ## 5 0.6663254 0.21375668 0.9801754 ## 7 0.6810784 0.19358022 0.9872807 ## 9 0.6876778 0.17545889 0.9907895 ## 11 0.6913460 0.16304106 0.9927193 ## 13 0.6901065 0.15165147 0.9941228 ## 15 0.6938565 0.14700566 0.9950000 ## 17 0.6936872 0.13148037 0.9958772 ## 19 0.6968690 0.11905986 0.9961404 ## 21 0.6990429 0.10767295 0.9971930 ## 23 0.7013093 0.10301777 0.9971053 ## 25 0.7038638 0.09214229 0.9976316 ## 27 0.7034258 0.08334204 0.9982456 ## 29 0.7061759 0.07454847 0.9981579 ## 31 0.7050670 0.06885301 0.9985088 ## 33 0.7048892 0.06316156 0.9985088 ## 35 0.7059717 0.05746743 0.9986842 ## 37 0.7061809 0.04711679 0.9992105 ## 39 0.7062836 0.04297171 0.9991228 ## 41 0.7064347 0.03831519 0.9991228 ## 43 0.7056465 0.03520638 0.9992982 ## ## ROC was used to select the optimal model using the largest value. ## The final value used for the model was k = 41. plot(knn_model) 5.8.4 Support vector machine model Challenge Apply a svm model, making sure you reuse the same train control object. Hint: Look at names(getModelInfo()) for all possible model names. svm_model &lt;- train(churn ~ ., churnTrain, metric = &quot;ROC&quot;, method = &quot;svmRadial&quot;, tuneLength = 10, trControl = myControl) print(svm_model) ## Support Vector Machines with Radial Basis Function Kernel ## ## 3333 samples ## 19 predictor ## 2 classes: &#39;yes&#39;, &#39;no&#39; ## ## No pre-processing ## Resampling: Bootstrapped (5 reps) ## Summary of sample sizes: 667, 666, 667, 667, 666 ## Resampling results across tuning parameters: ## ## C ROC Sens Spec ## 0.25 0.8076274 0.1324470 0.9890351 ## 0.50 0.8075759 0.1386847 0.9889474 ## 1.00 0.8076122 0.1692386 0.9856140 ## 2.00 0.8077675 0.1448689 0.9878070 ## 4.00 0.8118208 0.1770227 0.9871053 ## 8.00 0.8163109 0.1950757 0.9841228 ## 16.00 0.8104749 0.1899091 0.9828070 ## 32.00 0.8045082 0.1738576 0.9839474 ## 64.00 0.8001100 0.1464661 0.9864912 ## 128.00 0.7994143 0.1676480 0.9827193 ## ## Tuning parameter &#39;sigma&#39; was held constant at a value of 0.007394083 ## ROC was used to select the optimal model using the largest value. ## The final values used for the model were sigma = 0.007394083 and C = 8. plot(svm_model) 5.8.5 Naive Bayes Challenge Apply a naive Bayes model, making sure you reuse the same train control object. nb_model &lt;- train(churn ~ ., churnTrain, metric = &quot;ROC&quot;, method = &quot;naive_bayes&quot;, trControl = myControl) print(nb_model) ## Naive Bayes ## ## 3333 samples ## 19 predictor ## 2 classes: &#39;yes&#39;, &#39;no&#39; ## ## No pre-processing ## Resampling: Bootstrapped (5 reps) ## Summary of sample sizes: 667, 667, 667, 666, 666 ## Resampling results across tuning parameters: ## ## usekernel ROC Sens Spec ## FALSE 0.5540359 0.9497409 0.07912281 ## TRUE 0.8086525 0.0000000 1.00000000 ## ## Tuning parameter &#39;laplace&#39; was held constant at a value of 0 ## ## Tuning parameter &#39;adjust&#39; was held constant at a value of 1 ## ROC was used to select the optimal model using the largest value. ## The final values used for the model were laplace = 0, usekernel = TRUE ## and adjust = 1. plot(nb_model) 5.8.6 Comparing models We can now use the caret::resamples function that will compare the models and pick the one with the highest AUC and lowest AUC standard deviation. model_list &lt;- list(glmmet = glm_model, rf = rf_model, knn = knn_model, svm = svm_model, nb = nb_model) resamp &lt;- resamples(model_list) resamp ## ## Call: ## resamples.default(x = model_list) ## ## Models: glmmet, rf, knn, svm, nb ## Number of resamples: 5 ## Performance metrics: ROC, Sens, Spec ## Time estimates for: everything, final model fit summary(resamp) ## ## Call: ## summary.resamples(object = resamp) ## ## Models: glmmet, rf, knn, svm, nb ## Number of resamples: 5 ## ## ROC ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## glmmet 0.7739183 0.7755329 0.7801770 0.7785410 0.7813153 0.7817614 0 ## rf 0.8930595 0.8999960 0.9003610 0.8999424 0.9016521 0.9046433 0 ## knn 0.6968770 0.7006795 0.7059823 0.7064347 0.7078999 0.7207347 0 ## svm 0.8091833 0.8157088 0.8161544 0.8163109 0.8174223 0.8230858 0 ## nb 0.7954270 0.8004363 0.8118887 0.8086525 0.8157215 0.8197891 0 ## ## Sens ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## glmmet 0.007772021 0.01291990 0.01813472 0.01656157 0.02072539 0.02325581 ## rf 0.551813472 0.58914729 0.59173127 0.59368866 0.59844560 0.63730570 ## knn 0.012919897 0.02072539 0.03875969 0.03831519 0.04663212 0.07253886 ## svm 0.062176166 0.16839378 0.20671835 0.19507571 0.24093264 0.29715762 ## nb 0.000000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 ## NA&#39;s ## glmmet 0 ## rf 0 ## knn 0 ## svm 0 ## nb 0 ## ## Spec ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## glmmet 0.9973684 0.9982456 0.9986842 0.9986842 0.9991228 1.0000000 0 ## rf 0.9750000 0.9824561 0.9837719 0.9833333 0.9868421 0.9885965 0 ## knn 0.9978070 0.9986842 0.9991228 0.9991228 1.0000000 1.0000000 0 ## svm 0.9644737 0.9828947 0.9846491 0.9841228 0.9903509 0.9982456 0 ## nb 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 0 lattice::bwplot(resamp, metric = &quot;ROC&quot;) Figure 5.3: Comparing distributions of AUC values for various models. 5.8.7 Pre-processing The random forest appears to be the best one. This might be related to its ability to cope well with different types of input and require little pre-processing. Challenge If you haven’t done so, consider pre-processing the data prior to training for a model that didn’t perform well and assess whether pre-processing affected the modelling. svm_model1 &lt;- train(churn ~ ., churnTrain, metric = &quot;ROC&quot;, method = &quot;svmRadial&quot;, tuneLength = 10, trControl = myControl) svm_model2 &lt;- train(churn ~ ., churnTrain[, c(2, 6:20)], metric = &quot;ROC&quot;, method = &quot;svmRadial&quot;, preProcess = c(&quot;scale&quot;, &quot;center&quot;, &quot;pca&quot;), tuneLength = 10, trControl = myControl) model_list &lt;- list(svm1 = svm_model1, svm2 = svm_model2) resamp &lt;- resamples(model_list) summary(resamp) ## ## Call: ## summary.resamples(object = resamp) ## ## Models: svm1, svm2 ## Number of resamples: 5 ## ## ROC ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## svm1 0.8091526 0.8153293 0.8161635 0.8161290 0.8171700 0.8228297 0 ## svm2 0.8182375 0.8225025 0.8307211 0.8277856 0.8313062 0.8361610 0 ## ## Sens ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## svm1 0.1113990 0.1787565 0.2098446 0.2023256 0.2222222 0.2894057 0 ## svm2 0.3229974 0.3652850 0.4015544 0.4073516 0.4585492 0.4883721 0 ## ## Spec ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## svm1 0.9662281 0.9837719 0.9885965 0.9848246 0.9899123 0.9956140 0 ## svm2 0.9684211 0.9701754 0.9758772 0.9766667 0.9828947 0.9859649 0 bwplot(resamp, metric = &quot;ROC&quot;) 5.8.8 Predict using the best model Challenge Choose the best model using the resamples function and comparing the results and apply it to predict the churnTest labels. p &lt;- predict(rf_model, churnTest) confusionMatrix(p, churnTest$churn) ## Confusion Matrix and Statistics ## ## Reference ## Prediction yes no ## yes 166 3 ## no 58 1440 ## ## Accuracy : 0.9634 ## 95% CI : (0.9532, 0.9719) ## No Information Rate : 0.8656 ## P-Value [Acc &gt; NIR] : &lt; 2.2e-16 ## ## Kappa : 0.8245 ## ## Mcnemar&#39;s Test P-Value : 4.712e-12 ## ## Sensitivity : 0.74107 ## Specificity : 0.99792 ## Pos Pred Value : 0.98225 ## Neg Pred Value : 0.96128 ## Prevalence : 0.13437 ## Detection Rate : 0.09958 ## Detection Prevalence : 0.10138 ## Balanced Accuracy : 0.86950 ## ## &#39;Positive&#39; Class : yes ## There are exactly 238 available methods. See http://topepo.github.io/caret/train-models-by-tag.html for details.↩ "],
["6-final-notes.html", "Chapter 6 Final notes 6.1 Other learning algorithms 6.2 Model performance 6.3 Credit and acknowledgements 6.4 References and further reading 6.5 Session information", " Chapter 6 Final notes library(BiocStyle) 6.1 Other learning algorithms Semi-supervised learning The idea behind semi-supervised learning is to use labelled observations to guide the determination of relevant structure in the unlabelled data. The figures below described the phenoDisco algorithm described in Breckels et al. (2013). Semi-supervised learning and novelty detection Deep learning in R This book focuses on introductory material in R. This shouldn’t however give the impression that more modern approaches are not available. R has plenty of activity arounds deep learning such as, for example, the keras package, an interface to Keras, a high-level neural networks API. See this blog for an introduction. 6.2 Model performance When investigating multi-class problems, it is good to consider additional performance metrics and to inspect the confusion matrices in more details, to look if some classes suffer from greater mis-classification rates. Models accuracy can also evaluated using the F1 score, where \\(F1 = 2 ~ \\frac{precision \\times recall}{precision + recall}\\), calculated as the harmonic mean of the precision (\\(precision = \\frac{tp}{tp+fp}\\), a measure of exactness – returned output is a relevant result) and recall (\\(recall=\\frac{tp}{tp+fn}\\), a measure of completeness – indicating how much was missed from the output). What we are aiming for are high generalisation accuracy, i.e high \\(F1\\), indicating that the marker proteins in the test data set are consistently and correctly assigned by the algorithms. For a multi-class problem, the macro F1 (mean of class F1s) can be used. 6.3 Credit and acknowledgements Many parts of this course have been influenced by the DataCamp’s Machine Learning with R skill track, in particular the Machine Learning Toolbox (supervised learning chapter) and the Unsupervised Learning in R (unsupervised learning chapter) courses. Jamie Lendrum has addressed numerous typos in the first version. The very hands-on approach has also been influenced by the Software and Data Carpentry lessons and teaching styles. 6.4 References and further reading caret: Classification and Regression Training. Max Kuhn. https://CRAN.R-project.org/package=caret. Applied predictive modeling, Max Kuhn and Kjell Johnson (book webpage http://appliedpredictivemodeling.com/) and the caret book. An Introduction to Statistical Learning (with Applications in R). Gareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani. mlr: Machine Learning in R. Bischl B, Lang M, Kotthoff L, Schiffner J, Richter J, Studerus E, Casalicchio G and Jones Z (2016). Journal of Machine Learning Research, 17(170), pp. 1-5. https://github.com/mlr-org/mlr. DataCamp’s Machine Learning with R skill track (requires paid access). 6.5 Session information sessionInfo() ## R version 3.6.0 (2019-04-26) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.2 LTS ## ## Matrix products: default ## BLAS: /opt/R/3.6.0/lib/R/lib/libRblas.so ## LAPACK: /opt/R/3.6.0/lib/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] BiocStyle_2.12.0 logging_0.9-107 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.1 bookdown_0.11 digest_0.6.19 ## [4] crayon_1.3.4 rprojroot_1.3-2 backports_1.1.4 ## [7] magrittr_1.5 evaluate_0.14 stringi_1.4.3 ## [10] rstudioapi_0.10 rmarkdown_1.13 tools_3.6.0 ## [13] stringr_1.4.0 xfun_0.7 yaml_2.2.0 ## [16] compiler_3.6.0 BiocManager_1.30.4 htmltools_0.3.6 ## [19] knitr_1.23 "]
]
